#JavaScript数组值之多样操作

本篇主要总结常见的排序算法在JavaScript中的实现及js数组取最值，去重，篇幅较长，如有需要可以跳越阅读。

##JavaScript之最值

想一想给你一个数组，让你取最值，你会如何实现呢？这里我们只给出取最大值的实例。

- **遍历**

上代码：
```

    function max(arr) {
        var temp = arr[0];
        for (var i = 1; i < arr.length; i++) {
            if (arr[i] > temp) {
                temp = arr[i];
            }
        }
        return temp;
    }
```

- **apply借用Math.max()**

```

    function max(arr) {
        return Math.max.apply(null, arr);
    } 
```
apply有两个参数,第一个参数为执行环境，一个以数组形式传入参数。

##JavaScript之排序算法

主要介绍最常用的几种排序算法的JavaScript实现：桶排序，冒泡排序，快速排序。

###桶排序

试想一下，你们五个小伙伴考试微积分，分别考了5分，6分，3分，8分，6分，接下来按分数高低进行排名。
如何实现呢？
这里我们只需要一个数组就能轻易解决：

*大数组下标为待排序数组项的值，大数组值为其对应下标在待排序数组中出现次数，默认为0。大数组长度为待排序数组中最大值加1（因为下标从0开始）。*


```

    function barrelSort(arr) {
    	var _arr = [];
		var _max = Math.max.apply(null, arr); //借用取数组最大值
		var _num = _max + 1;
		while((_num--) >= 0) { //生成一个大一维数组，长度为数组最大值+1
			_arr[_num] = 0;//初始化大数组项全为0
		}
		var _len = arr.length;
		while ((_len--) >= 0) {//循环数组
			_arr[arr[_len]]++;//将数组项值对应为大数组下标,并统计数组项值出现次数，存入大数组
		}
		var _item = _max + 1;
		arr = [];//重新生成排序后的数组
		while ((_item--) >= 0)  {//循环大数组
			var k = 1;
			while((k++) <= _arr[_item]) {//统计大数组中出现次数大于0的下标值，并存入数组
				arr.push(_item);
			}
		}
		console.log(arr);
		return arr;
	}
```

- **时间复杂度O(m+n)** 
            
*如代码，第一个while循环m次（m为桶个数，即待排序数组最大值+1），第二个while循环n次(n为待排序数组长度)，最后嵌套while循环m+n次，即先循环大数组，然后只统计大数组中值大于0的对应下标，其实也就等于待排序数组长度，所以整个排序算法一共循环2*（m+n）次，其时间复杂度可为O(m+n)。

###冒泡排序

何谓冒泡排序呢，先来理解一下：

> 重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。因为越大的元素会经由交换慢慢“浮”到数列的顶端，故得名--冒泡。

- **趟** 从0开始循环到数组倒数第二个数，每次循环称为一趟。
- **冒泡** 从第一位数一直循环到倒数第二位数，依次两两比较，一次比较为一次冒泡。

*冒泡排序中一趟循环确定一位数字的正确位置，每趟循环都需要从当前数组序列的第一位数到倒数第二位数依次进行冒泡循环，最终确定排序后的数组序列。*

请看代码：

```

    function bubbleSort(arr) {
    	var _len = arr.length - 1;
		var t;
		for (var i = 0; i < _len; i++) {//从0开始循环到数组倒数第二个数，每次循环称为一趟
			for(var j = 0; j < _len - i; j++) {//从第一位数一直循环到倒数第二位数，每次循环为有若干次冒泡
				if (arr[j] < arr[j + 1]) {//比较两个数大小，根据要求交换位置，即冒泡，结束后进行下一次冒泡
					t = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = t;
				}
			}
		}
		console.log(arr);
		return arr;
	}
```

- **时间复杂度O(N^2)** 

如代码所示，冒泡排序算法只有一个双重嵌套循环，共循环n*n次，其时间复杂度即为O(N^2)。

